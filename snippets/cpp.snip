snippet     cout
  cout << ${0:TARGET} << endl;

snippet     couts
  rep(i, sz(${0:x})) cout << ${1:x}[i] << (i!=sz(${2:x})-1 ? " " : "\n");

snippet     ?
  (${1} ? ${2} : ${3})

snippet ina
  int a[n]; rep(i, n) {cin>>a[i];}

snippet     rep
  rep(${0}){
  }

snippet     rrep
  rrep(${0}){
  }

snippet     for
  for(int i=0; i<n; i++){${0}
  }

snippet     if
  if (${0}) {
  }

snippet     else
  else{${0}
  }

snippet     elif
  else if(${0}){
  }

snippet     while
  while (${0}){
  }

snippet     reprep
  rep(${1}) rep(${2}){${0}
  }

snippet     d
  dump(${0});

snippet     af
  assert(false);

snippet     sortkey
  sort(all(${0}), [](auto &left, auto &right){return left.second < right.second;});

snippet     perm
  do{
    ${0};
  } while (next_permutation(all(x)));

snippet     to_bin
  string to_bin(int n, int d){
    // nをd桁の2進数で表示する。
    stringstream ss;
    ss << bitset<20>(n);
    return ss.str().substr(20-d, d);
  }

snippet     warsharll
  // init
  int d[N][N]={};  // 必要があればglobalに
  rep(i, N)rep(j, N){
    d[i][j] = (i==j ? 0 : INF)
  }

  // input
  ${0};

  // calc
  rep(k, N){
    rep(i, N){
      rep(j, N){
        chmin(d[i][j], d[i][k]+d[k][j]);
      }
    }
  }
  dump_2d(d, N, N);

snippet digitdp
  rep(i, sz(S)){  //桁数
    rep(leq, 2){  //未満確定フラグ
      int lim = leq ? 9 : S[i]-'0';
      rep(d, lim+1){
        dp[i][leq || d<lim] += dp[i-1][leq];
      }
    }
  }

snippet rangesum
  int rangesum(int l, int r){
    // a[]: accumulative sum
    l = max(0, l);
    // r = min(0, n-1);
    if (l > r) return 0;
    return a[r] - (l-1>=0 ? a[l-1] : 0);
  }

snippet asv
  // acumulative sum vector {{{
  template<typename T=int>
  struct asvector : public vector<T> {
    using vector<T>::vector;
    vector<T> cum; //accumulative sum
    bool is_accumulated = false;

    public:
    T rsum(int l, int r) {  // return sum of [l, r] of data.
      if (!is_accumulated)
        _accumulate();
      l = std::max(0LL, l);
      r = std::min(r, sz(cum)-1);
      return _calc_rangesum(l, r);
    }

    T rsum(int r) {  // return sum of [0, r] of data.
      if (!is_accumulated)
        _accumulate();
      int l = 0;
      r = std::min(r, sz(cum)-1);
      return _calc_rangesum(l, r);
    }

    void _accumulate(){
      cum = vector<T>(*this);
      for(T i=1; i<sz(cum); i++){
        cum[i] = cum[i-1] + (*this)[i];
      }
      is_accumulated = true;
    }

    void push_back(T x){
      (*this).emplace_back(x);
      is_accumulated = false;
    }

    private:
    T _calc_rangesum(int l, int r) {
      if (l > r)
        return 0;
      else
        return cum[r] - (l-1>=0 ? cum[l-1] : 0);
    }
  };
  using asvi = asvector<int>;
  //}}}
